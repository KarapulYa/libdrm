diff --git a/libdrm/nouveau/Makefile.am b/libdrm/nouveau/Makefile.am
index 80fb780..688eeca 100644
--- a/libdrm/nouveau/Makefile.am
+++ b/libdrm/nouveau/Makefile.am
@@ -19,7 +19,9 @@ libdrm_nouveau_la_SOURCES = \
 			    nouveau_bo.c \
 			    nouveau_resource.c \
 			    nouveau_dma.c \
-			    nouveau_fence.c
+			    nouveau_fence.c \
+			    nouveau_dma.h \
+			    nouveau_private.h
 
 libdrm_nouveaucommonincludedir = ${includedir}/nouveau
 libdrm_nouveaucommoninclude_HEADERS = \
diff --git a/libdrm/nouveau/nouveau_bo.c b/libdrm/nouveau/nouveau_bo.c
index 6b9877f..023c6be 100644
--- a/libdrm/nouveau/nouveau_bo.c
+++ b/libdrm/nouveau/nouveau_bo.c
@@ -347,24 +347,25 @@ nouveau_bo_handle_get(struct nouveau_bo *bo, uint32_t *handle)
 	if (!bo || !handle)
 		return -EINVAL;
 
-	if (!nvdev->mm_enabled)
-		return -ENODEV;
-
 	if (!nvbo->global_handle) {
 		struct drm_gem_flink req;
  
 		ret = nouveau_bo_kalloc(nvbo, NULL);
 		if (ret)
 			return ret;
- 
-		req.handle = nvbo->handle;
-		ret = ioctl(nvdev->fd, DRM_IOCTL_GEM_FLINK, &req);
-		if (ret) {
-			nouveau_bo_kfree(nvbo);
-			return ret;
+
+		if (nvdev->mm_enabled) {
+			req.handle = nvbo->handle;
+			ret = ioctl(nvdev->fd, DRM_IOCTL_GEM_FLINK, &req);
+			if (ret) {
+				nouveau_bo_kfree(nvbo);
+				return ret;
+			}
+	 
+			nvbo->global_handle = req.name;
+		} else {
+			nvbo->global_handle = nvbo->offset;
 		}
- 
-		nvbo->global_handle = req.name;
 	}
  
 	*handle = nvbo->global_handle;
@@ -412,6 +413,8 @@ nouveau_bo_del_cb(void *priv)
 {
 	struct nouveau_bo_priv *nvbo = priv;
 
+	nouveau_fence_ref(NULL, &nvbo->fence);
+	nouveau_fence_ref(NULL, &nvbo->wr_fence);
 	nouveau_bo_kfree(nvbo);
 	free(nvbo);
 }
diff --git a/libdrm/nouveau/nouveau_device.c b/libdrm/nouveau/nouveau_device.c
index b5ac854..a61abb4 100644
--- a/libdrm/nouveau/nouveau_device.c
+++ b/libdrm/nouveau/nouveau_device.c
@@ -76,6 +76,22 @@ nouveau_device_open_existing(struct nouveau_device **dev, int close,
 	}
 	nvdev->base.vm_vram_base = value;
 
+	ret = nouveau_device_get_param(&nvdev->base,
+				       NOUVEAU_GETPARAM_FB_SIZE, &value);
+	if (ret) {
+		nouveau_device_close((void *)&nvdev);
+		return ret;
+	}
+	nvdev->vram_aper_size = value;
+
+	ret = nouveau_device_get_param(&nvdev->base,
+				       NOUVEAU_GETPARAM_AGP_SIZE, &value);
+	if (ret) {
+		nouveau_device_close((void *)&nvdev);
+		return ret;
+	}
+	nvdev->gart_aper_size = value;
+
 	ret = nouveau_bo_init(&nvdev->base);
 	if (ret) {
 		nouveau_device_close((void *)&nvdev);
@@ -128,7 +144,7 @@ nouveau_device_close(struct nouveau_device **dev)
 {
 	struct nouveau_device_priv *nvdev;
 
-	if (dev || !*dev)
+	if (!dev || !*dev)
 		return;
 	nvdev = nouveau_device(*dev);
 	*dev = NULL;
diff --git a/libdrm/nouveau/nouveau_drmif.h b/libdrm/nouveau/nouveau_drmif.h
index c21fba2..3791325 100644
--- a/libdrm/nouveau/nouveau_drmif.h
+++ b/libdrm/nouveau/nouveau_drmif.h
@@ -37,6 +37,9 @@ struct nouveau_device_priv {
 	int needs_close;
 
 	int mm_enabled;
+/*XXX: move to nouveau_device when interface gets bumped */
+	uint64_t vram_aper_size;
+	uint64_t gart_aper_size;
 };
 #define nouveau_device(n) ((struct nouveau_device_priv *)(n))
 
diff --git a/libdrm/nouveau/nouveau_fence.c b/libdrm/nouveau/nouveau_fence.c
index e31fc89..3346616 100644
--- a/libdrm/nouveau/nouveau_fence.c
+++ b/libdrm/nouveau/nouveau_fence.c
@@ -96,22 +96,16 @@ nouveau_fence_new(struct nouveau_channel *chan, struct nouveau_fence **fence)
 int
 nouveau_fence_ref(struct nouveau_fence *ref, struct nouveau_fence **fence)
 {
-	struct nouveau_fence_priv *nvfence;
-
 	if (!fence)
 		return -EINVAL;
 
-	if (*fence) {
-		nouveau_fence_del(fence);
-		*fence = NULL;
-	}
+	if (ref)
+		nouveau_fence(ref)->refcount++;
 
-	if (ref) {
-		nvfence = nouveau_fence(ref);
-		nvfence->refcount++;	
-		*fence = &nvfence->base;
-	}
+	if (*fence)
+		nouveau_fence_del(fence);
 
+	*fence = ref;
 	return 0;
 }
 
diff --git a/libdrm/nouveau/nouveau_private.h b/libdrm/nouveau/nouveau_private.h
index 9dc1b44..32a9052 100644
--- a/libdrm/nouveau/nouveau_private.h
+++ b/libdrm/nouveau/nouveau_private.h
@@ -173,7 +173,7 @@ struct nouveau_bo_priv {
 
 	/* Kernel object */
 	uint32_t global_handle;
-	unsigned handle;
+	drm_handle_t handle;
 	void *map;
 
 	/* Last known information from kernel on buffer status */
