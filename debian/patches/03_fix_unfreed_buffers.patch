From 97fdadee6a79f9406a55c235ee46104814321152 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <skeggsb@gmail.com>
Date: Thu, 05 Feb 2009 13:03:29 +0000
Subject: nouveau: fix some issues where buffer objects never get freed

---
diff --git a/libdrm/nouveau/nouveau_bo.c b/libdrm/nouveau/nouveau_bo.c
index 0ab426d..6b9877f 100644
--- a/libdrm/nouveau/nouveau_bo.c
+++ b/libdrm/nouveau/nouveau_bo.c
@@ -435,10 +435,18 @@ nouveau_bo_del(struct nouveau_bo **bo)
 	}
 
 	nouveau_bo_ufree(nvbo);
-	if (!nouveau_device(nvbo->base.device)->mm_enabled && nvbo->fence)
-		nouveau_fence_signal_cb(nvbo->fence, nouveau_bo_del_cb, nvbo);
-	else
+
+	if (!nouveau_device(nvbo->base.device)->mm_enabled && nvbo->fence) {
+		nouveau_fence_flush(nvbo->fence->channel);
+		if (nouveau_fence(nvbo->fence)->signalled) {
+			nouveau_bo_del_cb(nvbo);
+		} else {
+			nouveau_fence_signal_cb(nvbo->fence,
+					        nouveau_bo_del_cb, nvbo);
+		}
+	} else {
 		nouveau_bo_del_cb(nvbo);
+	}
 }
 
 int
@@ -786,7 +794,6 @@ nouveau_bo_busy(struct nouveau_bo *bo, uint32_t access)
 	return 1;
 }
 
-#include <stdio.h>
 struct drm_nouveau_gem_pushbuf_bo *
 nouveau_bo_emit_buffer(struct nouveau_channel *chan, struct nouveau_bo *bo)
 {
diff --git a/libdrm/nouveau/nouveau_channel.c b/libdrm/nouveau/nouveau_channel.c
index e0fb415..5de27dc 100644
--- a/libdrm/nouveau/nouveau_channel.c
+++ b/libdrm/nouveau/nouveau_channel.c
@@ -150,6 +150,17 @@ nouveau_channel_free(struct nouveau_channel **chan)
 	
 	FIRE_RING(&nvchan->base);
 
+	if (!nvdev->mm_enabled) {
+		struct nouveau_fence *fence = NULL;
+
+		/* Make sure all buffer objects on delayed delete queue
+		 * actually get freed.
+		 */
+		nouveau_fence_new(&nvchan->base, &fence);
+		nouveau_fence_emit(fence);
+		nouveau_fence_wait(&fence);
+	}
+
 	if (nvchan->notifier_block)
 		drmUnmap(nvchan->notifier_block, nvchan->drm.notifier_size);
 
--
cgit v0.8.2
