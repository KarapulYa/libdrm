Backport changes to libdrm-nouveau since 2.4.11

The nouveau drm kernel interface has changed (twice) since the
2.4.11 release.  We need these updates so that the DDX can 
use a recent nouveau.ko.

The list of git commits imported is:
c65a343ed29c24f812ca919f40dfeee948b6f14a
00fae87f96e1fc5198311feec81866bf9c53d0e1
2cb4c64d7310904b354365c2cbc263211e9eb4a1
3d4bfe8c893d016ef43d1ebf28e4607aa1f540a4
Index: libdrm-2.4.11/libdrm/nouveau/libdrm_nouveau.pc.in
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/libdrm_nouveau.pc.in	2009-07-03 09:44:58.969261108 +1000
+++ libdrm-2.4.11/libdrm/nouveau/libdrm_nouveau.pc.in	2009-07-03 09:45:36.937298103 +1000
@@ -5,6 +5,6 @@
 
 Name: libdrm_nouveau
 Description: Userspace interface to nouveau kernel DRM services
-Version: 0.5
+Version: 0.6
 Libs: -L${libdir} -ldrm_nouveau
 Cflags: -I${includedir} -I${includedir}/drm -I${includedir}/nouveau
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_bo.c
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_bo.c	2009-07-03 09:44:59.197260823 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_bo.c	2009-07-03 09:45:36.937298103 +1000
@@ -20,6 +20,9 @@
  * SOFTWARE.
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 #include <stdint.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -42,6 +45,19 @@
 }
 
 static int
+nouveau_bo_info(struct nouveau_bo_priv *nvbo, struct drm_nouveau_gem_info *arg)
+{
+	nvbo->handle = nvbo->base.handle = arg->handle;
+	nvbo->domain = arg->domain;
+	nvbo->size = nvbo->base.size = arg->size;
+	nvbo->offset = arg->offset;
+	nvbo->map_handle = arg->map_handle;
+	nvbo->base.tile_mode = arg->tile_mode;
+	nvbo->base.tile_flags = arg->tile_flags;
+	return 0;
+}
+
+static int
 nouveau_bo_allocated(struct nouveau_bo_priv *nvbo)
 {
 	if (nvbo->sysmem || nvbo->handle || (nvbo->flags & NOUVEAU_BO_PIN))
@@ -152,7 +168,8 @@
 	if (ret)
 		return ret;
 
-	nvbo->handle = req.map_handle;
+	nvbo->handle =
+	nvbo->map_handle = req.map_handle;
 	nvbo->size = req.size;
 	nvbo->offset = req.offset;
 	if (req.flags & (NOUVEAU_MEM_AGP | NOUVEAU_MEM_PCI))
@@ -169,6 +186,7 @@
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
 	struct drm_nouveau_gem_new req;
+	struct drm_nouveau_gem_info *info = &req.info;
 	int ret;
 
 	if (nvbo->handle || (nvbo->flags & NOUVEAU_BO_PIN))
@@ -178,38 +196,33 @@
 		return nouveau_bo_kalloc_nomm(nvbo);
 
 	req.channel_hint = chan ? chan->id : 0;
-
-	req.size = nvbo->size;
 	req.align = nvbo->align;
 
-	req.domain = 0;
 
-	if (nvbo->flags & NOUVEAU_BO_VRAM)
-		req.domain |= NOUVEAU_GEM_DOMAIN_VRAM;
+	info->size = nvbo->size;
+	info->domain = 0;
 
+	if (nvbo->flags & NOUVEAU_BO_VRAM)
+		info->domain |= NOUVEAU_GEM_DOMAIN_VRAM;
 	if (nvbo->flags & NOUVEAU_BO_GART)
-		req.domain |= NOUVEAU_GEM_DOMAIN_GART;
-
-	if (nvbo->flags & NOUVEAU_BO_TILED) {
-		req.domain |= NOUVEAU_GEM_DOMAIN_TILE;
-		if (nvbo->flags & NOUVEAU_BO_ZTILE)
-			req.domain |= NOUVEAU_GEM_DOMAIN_TILE_ZETA;
+		info->domain |= NOUVEAU_GEM_DOMAIN_GART;
+	if (!info->domain) {
+		info->domain |= (NOUVEAU_GEM_DOMAIN_VRAM |
+				 NOUVEAU_GEM_DOMAIN_GART);
 	}
 
-	if (!req.domain) {
-		req.domain |= (NOUVEAU_GEM_DOMAIN_VRAM |
-			       NOUVEAU_GEM_DOMAIN_GART);
-	}
+	if (nvbo->flags & NOUVEAU_BO_MAP)
+		info->domain |= NOUVEAU_GEM_DOMAIN_MAPPABLE;
+
+	info->tile_mode = nvbo->base.tile_mode;
+	info->tile_flags = nvbo->base.tile_flags;
 
 	ret = drmCommandWriteRead(nvdev->fd, DRM_NOUVEAU_GEM_NEW,
 				  &req, sizeof(req));
 	if (ret)
 		return ret;
-	nvbo->handle = nvbo->base.handle = req.handle;
-	nvbo->size = req.size;
-	nvbo->domain = req.domain;
-	nvbo->offset = req.offset;
 
+	nouveau_bo_info(nvbo, &req.info);
 	return 0;
 }
 
@@ -232,31 +245,30 @@
 nouveau_bo_kmap(struct nouveau_bo_priv *nvbo)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
-	struct drm_nouveau_gem_mmap req;
-	int ret;
 
 	if (nvbo->map)
 		return 0;
 
-	if (!nvbo->handle)
+	if (!nvbo->map_handle)
 		return -EINVAL;
 
 	if (!nvdev->mm_enabled)
 		return nouveau_bo_kmap_nomm(nvbo);
 
-	req.handle = nvbo->handle;
-	ret = drmCommandWriteRead(nvdev->fd, DRM_NOUVEAU_GEM_MMAP,
-				  &req, sizeof(req));
-	if (ret)
-		return ret;
+	nvbo->map = mmap(0, nvbo->size, PROT_READ | PROT_WRITE,
+			 MAP_SHARED, nvdev->fd, nvbo->map_handle);
+	if (nvbo->map == MAP_FAILED) {
+		nvbo->map = NULL;
+		return -errno;
+	}
 
-	nvbo->map = (void *)(unsigned long)req.vaddr;
 	return 0;
 }
 
 int
-nouveau_bo_new(struct nouveau_device *dev, uint32_t flags, int align,
-	       int size, struct nouveau_bo **bo)
+nouveau_bo_new_tile(struct nouveau_device *dev, uint32_t flags, int align,
+		    int size, uint32_t tile_mode, uint32_t tile_flags,
+		    struct nouveau_bo **bo)
 {
 	struct nouveau_bo_priv *nvbo;
 	int ret;
@@ -269,6 +281,8 @@
 		return -ENOMEM;
 	nvbo->base.device = dev;
 	nvbo->base.size = size;
+	nvbo->base.tile_mode = tile_mode;
+	nvbo->base.tile_flags = tile_flags;
 
 	nvbo->refcount = 1;
 	/* Don't set NOUVEAU_BO_PIN here, or nouveau_bo_allocated() will
@@ -279,13 +293,6 @@
 	nvbo->size = size;
 	nvbo->align = align;
 
-	/*XXX: murder me violently */
-	if (flags & NOUVEAU_BO_TILED) {
-		nvbo->base.tiled = 1;
-		if (flags & NOUVEAU_BO_ZTILE)
-			nvbo->base.tiled |= 2;
-	}
-
 	if (flags & NOUVEAU_BO_PIN) {
 		ret = nouveau_bo_pin((void *)nvbo, nvbo->flags);
 		if (ret) {
@@ -299,6 +306,22 @@
 }
 
 int
+nouveau_bo_new(struct nouveau_device *dev, uint32_t flags, int align,
+	       int size, struct nouveau_bo **bo)
+{
+	uint32_t tile_flags = 0;
+
+	if (flags & NOUVEAU_BO_TILED) {
+		if (flags & NOUVEAU_BO_ZTILE)
+			tile_flags = 0x2800;
+		else
+			tile_flags = 0x7000;
+	}
+
+	return nouveau_bo_new_tile(dev, flags, align, size, 0, tile_flags, bo);
+}
+
+int
 nouveau_bo_user(struct nouveau_device *dev, void *ptr, int size,
 		struct nouveau_bo **bo)
 {
@@ -338,6 +361,35 @@
 }
 
 int
+nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
+		struct nouveau_bo **bo)
+{
+	struct nouveau_device_priv *nvdev = nouveau_device(dev);
+	struct drm_nouveau_gem_info req;
+	struct nouveau_bo_priv *nvbo;
+	int ret;
+
+	if (!nvdev->mm_enabled)
+		return -ENODEV;
+
+	ret = nouveau_bo_new(dev, 0, 0, 0, bo);
+	if (ret)
+		return ret;
+	nvbo = nouveau_bo(*bo);
+
+	req.handle = handle;
+	ret = drmCommandWriteRead(nvdev->fd, DRM_NOUVEAU_GEM_INFO,
+				  &req, sizeof(req));
+	if (ret) {
+		nouveau_bo_ref(NULL, bo);
+		return ret;
+	}
+
+	nouveau_bo_info(nvbo, &req);
+	return 0;
+}
+
+int
 nouveau_bo_handle_get(struct nouveau_bo *bo, uint32_t *handle)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
@@ -381,12 +433,12 @@
 	struct drm_gem_open req;
 	int ret;
 
-	ret = nouveau_bo_new(dev, 0, 0, 0, bo);
-	if (ret)
-		return ret;
-	nvbo = nouveau_bo(*bo);
-
 	if (!nvdev->mm_enabled) {
+		ret = nouveau_bo_new(dev, 0, 0, 0, bo);
+		if (ret)
+			return ret;
+		nvbo = nouveau_bo(*bo);
+
 		nvbo->handle = 0;
 		nvbo->offset =  handle;
 		nvbo->domain = NOUVEAU_BO_VRAM;
@@ -401,8 +453,13 @@
 			return ret;
 		}
 
-		nvbo->size = req.size;
-		nvbo->handle = req.handle;
+		ret = nouveau_bo_wrap(dev, req.handle, bo);
+		if (ret) {
+			nouveau_bo_ref(NULL, bo);
+			return ret;
+		}
+
+		nvbo = nouveau_bo(*bo);
 	}
 
 	nvbo->base.handle = nvbo->handle;
@@ -507,17 +564,21 @@
 		return nouveau_bo_wait_nomm(bo, cpu_write);
 
 	req.handle = nvbo->handle;
-	ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_CPU_PREP,
-			      &req, sizeof(req));
+	do {
+		ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_CPU_PREP,
+				      &req, sizeof(req));
+	} while (ret == -EAGAIN);
 	if (ret)
 		return ret;
 
-	nvbo->write_marker = 0;
+	if (ret == 0)
+		nvbo->write_marker = 0;
 	return 0;
 }
 
 int
-nouveau_bo_map(struct nouveau_bo *bo, uint32_t flags)
+nouveau_bo_map_range(struct nouveau_bo *bo, uint32_t delta, uint32_t size,
+		     uint32_t flags)
 {
 	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
 	int ret;
@@ -540,23 +601,36 @@
 	}
 
 	if (nvbo->sysmem) {
-		bo->map = nvbo->sysmem;
+		bo->map = (char *)nvbo->sysmem + delta;
 	} else {
 		ret = nouveau_bo_kmap(nvbo);
 		if (ret)
 			return ret;
 
-		ret = nouveau_bo_wait(bo, (flags & NOUVEAU_BO_WR));
-		if (ret)
-			return ret;
+		if (!(flags & NOUVEAU_BO_NOSYNC)) {
+			ret = nouveau_bo_wait(bo, (flags & NOUVEAU_BO_WR));
+			if (ret)
+				return ret;
+		}
 
-		bo->map = nvbo->map;
+		bo->map = (char *)nvbo->map + delta;
 	}
 
 	return 0;
 }
 
 void
+nouveau_bo_map_flush(struct nouveau_bo *bo, uint32_t delta, uint32_t size)
+{
+}
+
+int
+nouveau_bo_map(struct nouveau_bo *bo, uint32_t flags)
+{
+	return nouveau_bo_map_range(bo, 0, bo->size, flags);
+}
+
+void
 nouveau_bo_unmap(struct nouveau_bo *bo)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
@@ -578,7 +652,7 @@
 nouveau_bo_validate_nomm(struct nouveau_bo_priv *nvbo, uint32_t flags)
 {
 	struct nouveau_bo *new = NULL;
-	uint32_t t_handle, t_domain, t_offset, t_size;
+	uint32_t t_handle, t_domain, t_offset, t_size, t_maph;
 	void *t_map;
 	int ret;
 
@@ -614,18 +688,21 @@
 	}
 
 	t_handle = nvbo->handle;
+	t_maph = nvbo->map_handle;
 	t_domain = nvbo->domain;
 	t_offset = nvbo->offset;
 	t_size = nvbo->size;
 	t_map = nvbo->map;
 
 	nvbo->handle = nouveau_bo(new)->handle;
+	nvbo->map_handle = nouveau_bo(new)->map_handle;
 	nvbo->domain = nouveau_bo(new)->domain;
 	nvbo->offset = nouveau_bo(new)->offset;
 	nvbo->size = nouveau_bo(new)->size;
 	nvbo->map = nouveau_bo(new)->map;
 
 	nouveau_bo(new)->handle = t_handle;
+	nouveau_bo(new)->map_handle = t_maph;
 	nouveau_bo(new)->domain = t_domain;
 	nouveau_bo(new)->offset = t_offset;
 	nouveau_bo(new)->size = t_size;
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_bo.h
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_bo.h	2009-07-03 09:44:59.245259523 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_bo.h	2009-07-03 09:45:36.937298103 +1000
@@ -37,6 +37,10 @@
 #define NOUVEAU_BO_LOCAL  (1 << 9)
 #define NOUVEAU_BO_TILED  (1 << 10)
 #define NOUVEAU_BO_ZTILE  (1 << 11)
+#define NOUVEAU_BO_INVAL  (1 << 12)
+#define NOUVEAU_BO_NOSYNC (1 << 13)
+#define NOUVEAU_BO_NOWAIT (1 << 14)
+#define NOUVEAU_BO_IFLUSH (1 << 15)
 #define NOUVEAU_BO_DUMMY  (1 << 31)
 
 struct nouveau_bo {
@@ -46,7 +50,8 @@
 	uint64_t size;
 	void *map;
 
-	int tiled;
+	uint32_t tile_mode;
+	uint32_t tile_flags;
 
 	/* Available when buffer is pinned *only* */
 	uint32_t flags;
@@ -58,6 +63,11 @@
 	       struct nouveau_bo **);
 
 int
+nouveau_bo_new_tile(struct nouveau_device *, uint32_t flags, int align,
+		    int size, uint32_t tile_mode, uint32_t tile_flags,
+		    struct nouveau_bo **);
+
+int
 nouveau_bo_user(struct nouveau_device *, void *ptr, int size,
 		struct nouveau_bo **);
 
@@ -66,6 +76,9 @@
 		uint32_t size, void *map, struct nouveau_bo **);
 
 int
+nouveau_bo_wrap(struct nouveau_device *, uint32_t handle, struct nouveau_bo **);
+
+int
 nouveau_bo_handle_get(struct nouveau_bo *, uint32_t *);
 
 int
@@ -76,6 +89,13 @@
 nouveau_bo_ref(struct nouveau_bo *, struct nouveau_bo **);
 
 int
+nouveau_bo_map_range(struct nouveau_bo *, uint32_t delta, uint32_t size,
+		     uint32_t flags);
+
+void
+nouveau_bo_map_flush(struct nouveau_bo *, uint32_t delta, uint32_t size);
+
+int
 nouveau_bo_map(struct nouveau_bo *, uint32_t flags);
 
 void
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_device.c
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_device.c	2009-07-03 09:44:59.397291495 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_device.c	2009-07-03 09:45:36.937298103 +1000
@@ -26,7 +26,7 @@
 
 #include "nouveau_private.h"
 
-#if NOUVEAU_DRM_HEADER_PATCHLEVEL != 12
+#if NOUVEAU_DRM_HEADER_PATCHLEVEL != 14
 #error nouveau_drm.h does not match expected patchlevel, update libdrm.
 #endif
 
@@ -82,7 +82,7 @@
 		nouveau_device_close((void *)&nvdev);
 		return ret;
 	}
-	nvdev->vram_aper_size = value;
+	nvdev->base.vm_vram_size = value;
 
 	ret = nouveau_device_get_param(&nvdev->base,
 				       NOUVEAU_GETPARAM_AGP_SIZE, &value);
@@ -90,7 +90,7 @@
 		nouveau_device_close((void *)&nvdev);
 		return ret;
 	}
-	nvdev->gart_aper_size = value;
+	nvdev->base.vm_gart_size = value;
 
 	ret = nouveau_bo_init(&nvdev->base);
 	if (ret) {
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_device.h
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_device.h	2009-07-03 09:44:59.433258566 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_device.h	2009-07-03 09:45:24.837260952 +1000
@@ -26,6 +26,8 @@
 struct nouveau_device {
 	unsigned chipset;
 	uint64_t vm_vram_base;
+	uint64_t vm_vram_size;
+	uint64_t vm_gart_size;
 };
 
 #endif
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_drmif.h
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_drmif.h	2009-07-03 09:44:59.525259080 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_drmif.h	2009-07-03 09:45:24.837260952 +1000
@@ -37,9 +37,6 @@
 	int needs_close;
 
 	int mm_enabled;
-/*XXX: move to nouveau_device when interface gets bumped */
-	uint64_t vram_aper_size;
-	uint64_t gart_aper_size;
 };
 #define nouveau_device(n) ((struct nouveau_device_priv *)(n))
 
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_private.h
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_private.h	2009-07-03 09:44:59.705259331 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_private.h	2009-07-03 09:45:24.837260952 +1000
@@ -174,6 +174,7 @@
 	/* Kernel object */
 	uint32_t global_handle;
 	drm_handle_t handle;
+	uint64_t map_handle;
 	void *map;
 
 	/* Last known information from kernel on buffer status */
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_pushbuf.c
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_pushbuf.c	2009-07-03 09:44:59.733258910 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_pushbuf.c	2009-07-03 09:45:36.937298103 +1000
@@ -60,8 +60,8 @@
 
 int
 nouveau_pushbuf_emit_reloc(struct nouveau_channel *chan, void *ptr,
-			   struct nouveau_bo *bo, uint32_t data, uint32_t flags,
-			   uint32_t vor, uint32_t tor)
+			   struct nouveau_bo *bo, uint32_t data, uint32_t data2,
+			   uint32_t flags, uint32_t vor, uint32_t tor)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(chan->device);
 	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(chan->pushbuf);
Index: libdrm-2.4.11/libdrm/nouveau/nouveau_pushbuf.h
===================================================================
--- libdrm-2.4.11.orig/libdrm/nouveau/nouveau_pushbuf.h	2009-07-03 09:44:59.769267677 +1000
+++ libdrm-2.4.11/libdrm/nouveau/nouveau_pushbuf.h	2009-07-03 09:45:36.941298751 +1000
@@ -41,8 +41,8 @@
 
 int
 nouveau_pushbuf_emit_reloc(struct nouveau_channel *, void *ptr,
-			   struct nouveau_bo *, uint32_t data, uint32_t flags,
-			   uint32_t vor, uint32_t tor);
+			   struct nouveau_bo *, uint32_t data, uint32_t data2,
+			   uint32_t flags, uint32_t vor, uint32_t tor);
 
 /* Push buffer access macros */
 static __inline__ void
@@ -121,7 +121,16 @@
 	  unsigned data, unsigned flags, unsigned vor, unsigned tor)
 {
 	nouveau_pushbuf_emit_reloc(chan, chan->pushbuf->cur++, bo,
-				   data, flags, vor, tor);
+				   data, 0, flags, vor, tor);
+}
+
+static __inline__ void
+OUT_RELOC2(struct nouveau_channel *chan, struct nouveau_bo *bo,
+	   unsigned data, unsigned data2, unsigned flags,
+	   unsigned vor, unsigned tor)
+{
+	nouveau_pushbuf_emit_reloc(chan, chan->pushbuf->cur++, bo,
+				   data, data2, flags, vor, tor);
 }
 
 /* Raw data + flags depending on FB/TT buffer */
@@ -149,6 +158,14 @@
 	OUT_RELOC(chan, bo, delta, flags | NOUVEAU_BO_LOW, 0, 0);
 }
 
+/* Low 32-bits of offset + GPU linear access range info */
+static __inline__ void
+OUT_RELOCr(struct nouveau_channel *chan, struct nouveau_bo *bo,
+	   unsigned delta, unsigned size, unsigned flags)
+{
+	OUT_RELOC2(chan, bo, delta, size, flags | NOUVEAU_BO_LOW, 0, 0);
+}
+
 /* High 32-bits of offset */
 static __inline__ void
 OUT_RELOCh(struct nouveau_channel *chan, struct nouveau_bo *bo,
Index: libdrm-2.4.11/shared-core/nouveau_drm.h
===================================================================
--- libdrm-2.4.11.orig/shared-core/nouveau_drm.h	2009-07-03 09:45:09.117799596 +1000
+++ libdrm-2.4.11/shared-core/nouveau_drm.h	2009-07-03 09:45:36.941298751 +1000
@@ -25,7 +25,7 @@
 #ifndef __NOUVEAU_DRM_H__
 #define __NOUVEAU_DRM_H__
 
-#define NOUVEAU_DRM_HEADER_PATCHLEVEL 12
+#define NOUVEAU_DRM_HEADER_PATCHLEVEL 14
 
 struct drm_nouveau_channel_alloc {
 	uint32_t     fb_ctxdma_handle;
@@ -153,17 +153,22 @@
 #define NOUVEAU_GEM_DOMAIN_CPU       (1 << 0)
 #define NOUVEAU_GEM_DOMAIN_VRAM      (1 << 1)
 #define NOUVEAU_GEM_DOMAIN_GART      (1 << 2)
-#define NOUVEAU_GEM_DOMAIN_NOMAP     (1 << 3)
-#define NOUVEAU_GEM_DOMAIN_TILE      (1 << 30)
-#define NOUVEAU_GEM_DOMAIN_TILE_ZETA (1 << 31)
+#define NOUVEAU_GEM_DOMAIN_MAPPABLE  (1 << 3)
 
-struct drm_nouveau_gem_new {
+struct drm_nouveau_gem_info {
+	uint32_t handle;
+	uint32_t domain;
 	uint64_t size;
+	uint64_t offset;
+	uint64_t map_handle;
+	uint32_t tile_mode;
+	uint32_t tile_flags;
+};
+
+struct drm_nouveau_gem_new {
+	struct drm_nouveau_gem_info info;
 	uint32_t channel_hint;
 	uint32_t align;
-	uint32_t handle;
-	uint32_t domain;
-	uint32_t offset;
 };
 
 struct drm_nouveau_gem_pushbuf_bo {
@@ -223,12 +228,6 @@
 	uint32_t handle;
 };
 
-struct drm_nouveau_gem_mmap {
-	uint32_t handle;
-	uint32_t pad;
-	uint64_t vaddr;
-};
-
 struct drm_nouveau_gem_cpu_prep {
 	uint32_t handle;
 };
@@ -291,9 +290,9 @@
 #define DRM_NOUVEAU_GEM_PUSHBUF_CALL   0x42
 #define DRM_NOUVEAU_GEM_PIN            0x43
 #define DRM_NOUVEAU_GEM_UNPIN          0x44
-#define DRM_NOUVEAU_GEM_MMAP           0x45
-#define DRM_NOUVEAU_GEM_CPU_PREP       0x46
-#define DRM_NOUVEAU_GEM_CPU_FINI       0x47
-#define DRM_NOUVEAU_GEM_TILE           0x48
+#define DRM_NOUVEAU_GEM_CPU_PREP       0x45
+#define DRM_NOUVEAU_GEM_CPU_FINI       0x46
+#define DRM_NOUVEAU_GEM_TILE           0x47
+#define DRM_NOUVEAU_GEM_INFO           0x48
 
 #endif /* __NOUVEAU_DRM_H__ */
